import * as z from "zod";
import type { DeepReadonlyObject } from "./util";
export declare type SimpleSchema<TOut = any, TIn = any> = z.ZodType<TOut, z.ZodTypeDef, TIn>;
export declare type DetailedSpec<TSchema extends SimpleSchema = SimpleSchema<unknown, unknown>> = TSchema extends SimpleSchema<any, infer TIn> ? {
    /**
     * The Zod schema that will be used to parse the passed environment value
     * (or any provided default).
     */
    schema: TSchema;
    /**
     * A description of this env var that's provided as help text if the
     * passed value fails validation, or is required but missing.
     */
    description?: string;
    /**
     * An object that maps `NODE_ENV` values to default values to pass to the
     * schema for this var when the var isn't defined in the environment. For
     * example, you could specify `{ production: "my.cool.website",
     * development: "localhost:9021" }` to use a local hostname in
     * development.
     *
     * A special key for this object is `_`, which means "the default when
     * `NODE_ENV` isn't defined or doesn't match any other provided default."
     *
     * You can also use `.default()` in a Zod schema to provide a default.
     * (For example, `z.number().gte(20).default(50)`.)
     */
    defaults?: Record<string, TIn | undefined>;
} : never;
export declare type Schemas = Record<string, SimpleSchema | DetailedSpec>;
declare type DetailedSpecKeys = keyof DetailedSpec;
export declare type RestrictSchemas<T extends Schemas> = {
    [K in keyof T]: T[K] extends SimpleSchema ? SimpleSchema : T[K] extends DetailedSpec ? DetailedSpec<T[K]["schema"]> & Omit<Record<keyof T[K], never>, DetailedSpecKeys> : never;
};
export declare type ParsedSchema<T extends Schemas> = T extends any ? {
    [K in keyof T]: T[K] extends SimpleSchema<infer TOut> ? TOut : T[K] extends DetailedSpec ? T[K]["schema"] extends SimpleSchema<infer TOut> ? TOut : never : never;
} : never;
/**
 * Since there might be a provided default value of `null` or `undefined`, we
 * return a tuple that also indicates whether we found a default.
 */
export declare function resolveDefaultValueForSpec<TIn = unknown>(defaults: Record<string, TIn> | undefined, nodeEnv: string | undefined): [hasDefault: boolean, defaultValue: TIn | undefined];
/**
 * Mostly an internal convenience function for testing. Returns the input
 * parameter unchanged, but with the same inference used in `parseEnv` applied.
 */
export declare const inferSchemas: <T extends Schemas>(schemas: T & RestrictSchemas<T>) => T & RestrictSchemas<T>;
/**
 * Parses the passed environment object using the provided map of Zod schemas
 * and returns the immutably-typed, parsed environment..
 */
export declare function parseEnv<T extends Schemas>(env: Record<string, string | undefined>, schemas: T & RestrictSchemas<T>): DeepReadonlyObject<ParsedSchema<T>>;
export {};
